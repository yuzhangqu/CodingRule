# C++编程规范（精简版）

## 头文件

### 1. `#define`保护
命名格式为：`<PROJECT>_<PATH>_<FILE>_H_`（待定）

### 2. 头文件依赖
使用前置声明尽量减少头文件中`#include`的数量。例如：头文件中用到类`FILE`，但不需要访问`FILE`的声明，则头文件中只需前置声明`class File`，无需include头文件。

以下情况可以做到使用类`Foo`而无需访问类的定义：
1. 将数据成员类型声明为`Foo *`或`Foo &`；
2. 参数、返回值类型为`Foo`的函数只是声明（但不定义实现）；
3. 静态数据成员的类型可以被声明为`Foo`，因为静态数据成员的定义在类定义之外。

注：不建议仅仅为了减少包含头文件就使用指针成员替代对象成员。

### 3. 函数参数顺序
定义函数时，参数顺序为：输入参数在前，输出参数在后。

### 4. 包含文件的名称及次序
项目内头文件应按照项目源代码目录树结构排列，相同目录下头文件按字母序排列。

例如：`src/foo/fooserver.cc`中包含头文件的次序如下：
```cpp
#include "foo/fooserver.h"  // 优先位置

#include <sys/types.h>  // C系统文件
#include <unistd.h>

#include <hash_map>  // 库头文件
#include <vector>

#include "base/basictypes.h"  // 本项目内头文件
#include "base/commandlineflags.h"
```

## 作用域

### 1. 命名空间
命名空间将除文件包含、全局标识的声明/定义以及类的前置声明外的整个源文件封装起来，以同其他命名空间相区分。
```cpp
namespace mynamespace {
// 所有声明都置于命名空间中，注意不要使用缩进
class MyClass {
};
}  // namespace mynamespace（结束时用注释标识）
```

在`.cc`文件、`.h`文件的函数或类中，可以使用`using`，其他地方禁止使用，防止污染命名空间。

相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用命名空间。

### 2. 局部变量
将函数变量尽可能置于最小作用域内（离第一次使用越近越好），在声明变量时将其初始化。

注：如果变量是一个对象，每次进入作用域都要调用构造函数，每次退出作用域都要调用析构函数。例如：
```cpp
// 低效的实现
for (int i = 0; i < 1000000; ++i) {
    Foo f;  // 构造函数和析构函数分别调用1000000次
	f.DoSomething(i);
}

// 更好的实现
Foo f;
for (int i = 0; i < 1000000; ++i) {
	f.DoSomething(i);
}
```

### 3. 全局变量
1. 禁止使用`class`类型的全局变量（包括`string`、`vector`等等），內建类型和由內建类型构成的没有构造函数的结构体可以使用。如果一定要使用`class`类型的全局变量，请使用单件模式（singleton pattern）；
2. 全局的字符串常量，使用C风格的字符串，不要使用STL的字符串；
    `const char str[] = "hello";`
3. 大多数全局变量应该考虑作为类的静态数据成员；
4. 只在`.cc`文件中使用的全局变量，应将其定义到不具名命名空间中，或使用`static`限制作用域；
5. 静态成员变量视作全局变量，不能是`class`类型。

## C++类

### 1. 构造函数的职责
构造函数只进行没有实际意义的（因为成员变量的“有意义”的值大多不在构造函数中确定）初始化，可能的话，使用`init()`方法集中初始化为有意义的数据，并（或）增加一个成员标记用于指示对象是否已经初始化成功。

### 2. 默认构造函数
如果类中定义了成员变量，没有提供其他的构造函数，你需要定义一个默认构造函数。如果你定义的类继承现有类，而又没有增加新的成员变量，则不需要为新类定义默认构造函数。

### 3. 显式构造函数
对单参数构造函数使用`explicit`关键字，防止隐式转换。拷贝构造函数可以不声明为`explicit`。

### 4. 拷贝构造函数
仅在代码中需要拷贝一个类的对象的时候使用拷贝构造函数。如果不需要拷贝，可以在类的`private`成员中添加空的拷贝构造函数和赋值操作。
```cpp
class Foo {
public:
    Foo(int f);
	~Foo();

private:
    Foo(const Foo&);
	void operator=(const Foo&);
};
```

### 5. 继承
所有的继承必须是`public`的。

- 父类的纯虚函数：子类只继承接口，但必须实现其接口；
- 父类的虚函数：子类继承接口和实现，可以覆写（`override`），也可以使用默认版本。当覆写虚函数时，应在子类中明确声明其为`virtual`，提高可读性；
- 父类的非虚函数：子类继承接口和实现，不可以覆写。
- 如果类中有虚函数，其析构函数应该为虚函数。
- 限定仅在子类访问的成员函数为`protected`。

### 6. 存取控制
将数据成员私有化，并提供相关存取函数。如：定义变量`foo_`及取值函数`foo()`、赋值函数`set_foo()`。存取函数的定义一般内联在头文件中。

### 7. 声明次序
定义次序如下：`public`、`protected`、`private`，如果哪一块没有，直接忽略即可。

每一块中，声明次序一般如下：
1. `typedefs`和`enums`；
2. 常量；
3. 构造函数；
4. 析构函数；
5. 成员函数（含静态成员函数）；
6. 数据成员（含静态数据成员）。

`.cc`文件中函数的定义应尽可能和声明次序一致。

### 8. 编写短小函数
如果函数超过40行，可以考虑在不影响程序结构的情况下将其分割。