# C++编程规范（精简版）

## 头文件

### 1. `#define`保护
命名格式为：`<PROJECT>_<PATH>_<FILE>_H_`（待定）

### 2. 头文件依赖
使用前置声明尽量减少头文件中`#include`的数量。例如：头文件中用到类`FILE`，但不需要访问`FILE`的声明，则头文件中只需前置声明`class File`，无需include头文件。

以下情况可以做到使用类`Foo`而无需访问类的定义：
1. 将数据成员类型声明为`Foo *`或`Foo &`；
2. 参数、返回值类型为`Foo`的函数只是声明（但不定义实现）；
3. 静态数据成员的类型可以被声明为`Foo`，因为静态数据成员的定义在类定义之外。

注：不建议仅仅为了减少包含头文件就使用指针成员替代对象成员。

### 3. 函数参数顺序
定义函数时，参数顺序为：输入参数在前，输出参数在后。

### 4. 包含文件的名称及次序
项目内头文件应按照项目源代码目录树结构排列，相同目录下头文件按字母序排列。

例如：`src/foo/fooserver.cc`中包含头文件的次序如下：
```cpp
#include "foo/fooserver.h"  // 优先位置

#include <sys/types.h>  // C系统文件
#include <unistd.h>

#include <hash_map>  // 库头文件
#include <vector>

#include "base/basictypes.h"  // 本项目内头文件
#include "base/commandlineflags.h"
```

## 作用域

### 1. 命名空间
命名空间将除文件包含、全局标识的声明/定义以及类的前置声明外的整个源文件封装起来，以同其他命名空间相区分。
```cpp
namespace mynamespace {
// 所有声明都置于命名空间中，注意不要使用缩进
class MyClass {
};
}  // namespace mynamespace（结束时用注释标识）
```

在`.cc`文件、`.h`文件的函数或类中，可以使用`using`，其他地方禁止使用，防止污染命名空间。

相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用命名空间。

### 2. 局部变量
将函数变量尽可能置于最小作用域内（离第一次使用越近越好），在声明变量时将其初始化。

注：如果变量是一个对象，每次进入作用域都要调用构造函数，每次退出作用域都要调用析构函数。例如：
```cpp
// 低效的实现
for (int i = 0; i < 1000000; ++i) {
    Foo f;  // 构造函数和析构函数分别调用1000000次
    f.DoSomething(i);
}

// 更好的实现
Foo f;
for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
}
```

### 3. 全局变量
1. 禁止使用`class`类型的全局变量（包括`string`、`vector`等等），內建类型和由內建类型构成的没有构造函数的结构体可以使用。如果一定要使用`class`类型的全局变量，请使用单件模式（singleton pattern）；
2. 全局的字符串常量，使用C风格的字符串，不要使用STL的字符串；
    `const char str[] = "hello";`
3. 大多数全局变量应该考虑作为类的静态数据成员；
4. 只在`.cc`文件中使用的全局变量，应将其定义到不具名命名空间中，或使用`static`限制作用域；
5. 静态成员变量视作全局变量，不能是`class`类型。

## C++类

### 1. 构造函数的职责
构造函数只进行没有实际意义的（因为成员变量的“有意义”的值大多不在构造函数中确定）初始化，可能的话，使用`init()`方法集中初始化为有意义的数据，并（或）增加一个成员标记用于指示对象是否已经初始化成功。

### 2. 默认构造函数
如果类中定义了成员变量，没有提供其他的构造函数，你需要定义一个默认构造函数。如果你定义的类继承现有类，而又没有增加新的成员变量，则不需要为新类定义默认构造函数。

### 3. 显式构造函数
对单参数构造函数使用`explicit`关键字，防止隐式转换。拷贝构造函数可以不声明为`explicit`。

### 4. 拷贝构造函数
仅在代码中需要拷贝一个类的对象的时候使用拷贝构造函数。如果不需要拷贝，可以在类的`private`成员中添加空的拷贝构造函数和赋值操作。
```cpp
class Foo {
public:
    Foo(int f);
    ~Foo();

private:
    Foo(const Foo&);
    void operator=(const Foo&);
};
```

### 5. 继承
所有的继承必须是`public`的。

- 父类的纯虚函数：子类只继承接口，但必须实现其接口；
- 父类的虚函数：子类继承接口和实现，可以覆写（`override`），也可以使用默认版本。当覆写虚函数时，应在子类中明确声明其为`virtual`，提高可读性；
- 父类的非虚函数：子类继承接口和实现，不可以覆写。
- 如果类中有虚函数，其析构函数应该为虚函数。
- 限定仅在子类访问的成员函数为`protected`。

### 6. 存取控制
将数据成员私有化，并提供相关存取函数。如：定义变量`foo_`及取值函数`foo()`、赋值函数`set_foo()`。存取函数的定义一般内联在头文件中。

### 7. 声明次序
定义次序如下：`public`、`protected`、`private`，如果哪一块没有，直接忽略即可。

每一块中，声明次序一般如下：
1. `typedefs`和`enums`；
2. 常量；
3. 构造函数；
4. 析构函数；
5. 成员函数（含静态成员函数）；
6. 数据成员（含静态数据成员）。

`.cc`文件中函数的定义应尽可能和声明次序一致。

### 8. 编写短小函数
如果函数超过40行，可以考虑在不影响程序结构的情况下将其分割。

## 其他C++特性

### 1. 引用参数
所有按引用传递的参数必须加上`const`。输入参数为值或常引用，输出参数为指针。

### 2. 函数重载
仅在输入参数类型不同、功能相同时使用重载函数，不要使用函数重载模仿缺省函数参数。

```cpp
class MyClass {
public:
    void Analyze(const string &text);
    void Analyze(const char *text, size_t textlen);
};
```

与其重载一个函数，不如考虑让函数名包含参数信息，例如：`AppendString()`、`AppendInt()`。

### 3. 缺省参数
禁止使用缺省函数参数。避免使用可能不为程序员所知的缺省参数。

### 4. 变长数组和`alloca()`
禁止使用变长数组和`alloca()`。

### 5. 友元
允许合理使用友元类及友元函数。友元延伸了类的封装界线，当你希望只允许另一个类访问某个成员时，使用友元通常比将其声明为`public`要好得多。

### 6. 异常
不要使用C++异常。引入异常会牵连到所有依赖代码，会导致程序控制流通过查看代码无法确定。

### 7. 运行时类型识别RTTI
禁止使用RTTI。如果你需要在运行期间确定一个对象的类型，这通常说明你需要重新考虑你的类的设计。

### 8. 类型转换
使用C++风格而不要使用C风格类型转换。

1. `static_cast`：和C风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上转换；
2. `const_cast`：移除`const`属性；
3. `reinterpret_cast`：指针类型和整型或其他指针间不安全的相互转换（仅在你知道在做什么时使用）；
4. `dynamic_cast`：除测试外不要使用，参考RTTI。

### 9. 流
只在记录日志时使用流，其他使用`printf` + `read`/`write`。

### 10. 前置自增和自减
前置自增通常比后置自增效率更高，在不考虑表达式的值得情况下，使用前置自增和自减。

### 11. `const`的使用
尽可能地使用`const`。

1. 如果函数不会修改传入的引用或指针类型的参数，这样的参数应该为`const`；
2. 如果函数不会修改任何数据成员，也应该是`const`；
3. 不要返回对数据成员的非`const`指针或引用；
4. 如果数据成员在对象构造之后不再改变，可将其定义为`const`；
5. `const`的位置建议在前面。

### 12. 整型
- `<stdint.h>`定义了`int_16_t`、`int64_t`等整型，在需要确定大小的整型时可以使用它们代替`short`、`long long`等。
- 不要使用无符号整型，除非你是在表示一个位组（bit pattern）而不是一个数值。即使数值不会为负值也不要使用无符号类型，使用断言来保护数据。

### 13. 预处理宏
除了`#define`防止头文件重复包含外，不建议使用宏。

### 14. 0和`NULL`
- 整数：0
- 实数：0.0
- 指针：`NULL`
- 字符串：'\0'

### 15. `sizeof`
尽可能使用`sizeof(varname)`代替`sizeof(type)`。因为前者在变量类型改变时代码自动同步。

## 命名约定

### 1. 通用命名规则
- 函数命名、变量命名、文件命名应具有描述性，不要过度缩写。
- 类型和变量应该是名词，如：`FileOpener`、`num_errors`。
- 函数名通常是指令性的，如：`OpenFile()`、`set_num_errors()`。
- 除非放到项目外也非常明了，否则不要使用缩写。

### 2. 文件命名
- 文件名要全部小写，可以包含下划线`_`和短线`-`，如：`my_useful_class.cc`。
- C++文件以`.cc`结尾，头文件以`.h`结尾。
- 定义类时文件名一般成对出现，如：`foo_bar.h`和`foo_bar.cc`对应类`FooBar`。

### 3. 类型命名
- 类型命名每个单词以大写字母开头，不包含下划线，如：`MyExcitingClass`。
- 类型命名规则适用于：类、结构体、`typedef`、枚举。

### 4. 变量命名
- 变量名一律小写，单词间以下划线相连，如：`my_exciting_local_variable`。
- 类的成员变量以下划线结尾，如：`my_exciting_member_variable_`。
- 结构体的数据成员可以和普通变量一样，不用以下划线结尾。
- 全局变量少用，可以以`g_`作为前缀与局部变量区分。

### 5. 常量命名
在名称前加`k`，如；`const int kDaysInAWeek = 7;`

### 6. 函数命名
- 普通函数：函数名以大写字母开头，每个单词首字母大写，没有下划线，如：`DeleteUrl()`。
- 存取函数：函数名要与存取的变量名匹配，如`num_entries_`对应的存取函数：`num_entries()`和`set_num_entries(int num_entries)`。
- 短小的内联函数名也可以使用小写字母。

### 7. 命名空间
命名空间的名称是全小写的，其命名基于项目名称和目录结构。

### 8. 枚举命名
- 枚举名称属于类型名称，因此大小写混合，如：`UrlTableErrors`。
- 枚举值应全部大写，单词间以下划线相连。

### 9. 宏命名
如果绝对要用，其命名像枚举命名一样全部大写，使用下划线相连。

### 10. 命名规则外
当命名与现有C/C++实体相似的对象时，可参考现有命名约定：
- `bigopen()`：参考`open()`；
- `sparse_hash_map`：STL相似实体，参考STL命名约定；
- `LONGLONG_MAX`：类似`INT_MAX`。

## 代码注释
