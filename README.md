# C++编程规范（精简版）

## 一、命名约定

### 1. 通用命名规则
- 函数命名、变量命名、文件命名应具有描述性，不要过度缩写；
- 类型（`FileOpener`）和变量（`num_errors`）应该是名词；
- 函数名通常是指令性的，如：`OpenFile()`；
- 谨慎使用缩写，除非该缩写大部分人都非常明了。

### 2. 文件命名
- 文件名要全部小写，可以包含下划线`_`和短线`-`，如：`my_useful_class.cc`;
- C++文件以`.cc`结尾，头文件以`.h`结尾;
- 定义类时文件名一般成对出现，如：`foo_bar.h`和`foo_bar.cc`对应类`FooBar`。

### 3. 类型命名
- 类型命名每个单词以大写字母开头，不包含下划线，如：`MyExcitingClass`;
- 类型命名规则适用于：类、结构体、`typedef`、枚举。

### 4. 变量命名
- 变量名一律小写，单词间以下划线相连，如：`my_exciting_local_variable`;
- 类的成员变量以下划线结尾，如：`my_exciting_member_variable_`;
- 结构体的数据成员可以和普通变量一样，不用以下划线结尾;
- 谨慎使用全局变量，如果必须要用，以`g_`作为前缀与局部变量区分。

### 5. 常量命名
- 在名称前加`k`，如：`const int kDaysInAWeek = 7;`

### 6. 函数命名
- 普通函数：函数名以大写字母开头，每个单词首字母大写，没有下划线，如：`DeleteUrl()`;
- 存取函数：函数名要与存取的变量名匹配，如`num_entries_`对应的存取函数：`num_entries()`和`set_num_entries(int num_entries)`;
- 短小的内联函数名也可以使用小写字母。

### 7. 枚举命名
- 枚举名称属于类型名称，规则参见第3条，如：`UrlTableErrors`;
- 枚举值应全部大写，单词间以下划线`_`相连。

### 8. 宏命名
- 谨慎使用宏，如果必须要用，其命名像枚举值一样全部大写，使用下划线`_`相连。

### 9. 命名空间
- 命名空间的名称是全小写的，其命名基于项目名称和目录结构。

### 10. 命名规则外
当命名与现有C/C++实体相似的对象时，可参考现有命名约定：
- `bigopen()`：与`open()`相似；
- `sparse_hash_map`：与STL相似；
- `LONGLONG_MAX`：与`INT_MAX`相似。

## 二、格式

### 1. 行长度
- 每一行代码字符数不超过80个。

### 2. 空格 vs. Tab
- 只使用空格，每次缩进2个空格。设定编辑器将tab转为空格。

### 3. 函数声明与定义
- 规则文字如下，不看字可以直接看代码示例;
- 返回值、函数名和左圆括号在同一行；
- 函数名和左圆括号间没有空格；
- 圆括号和参数间没有空格；
- 右圆括号和左大括号间有一个空格；
- 左大括号在最后一个参数同一行的末尾处；
- 右大括号单独位于函数最后一行；
- 函数声明和实现处的所有形参名称保持一致；
- 形参尽可能对齐；
- 缺省缩进为2个空格；
- 独立封装的参数保持4个空格缩进；
- 如果函数为`const`的，关键字`const`应与最后一个参数位于同一行；
- 如果有些参数没有用到，在函数定义处将参数名注释起来。如：`void Circle::Rotate(double /*radians*/) {}`。

```cpp
// 一般情况
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}

// 函数头所在行只能放下第一个参数
ReturnType ClassName::ReallyLongFunctionName(Type par_name1,
                                             Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}

// 函数头一个参数也放不下
ReturnType ClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 换行的参数应缩进4个空格
    Type par_name2,
    Type par_name3) const {  // const关键字跟最后一个参数同行
  DoSomething();  // 代码的缩进还是2个空格
  ...
}
```

### 4. 函数调用
1. 尽量放在同一行；
2. 如果一行放不下，可断为多行，后面每一行都和第一个实参对齐；
3. 左圆括号后和右圆括号前不要留空格；
4. 如果函数参数比较多，可以出于可读性的考虑每行只放一个参数；
5. 如果函数名太长，可以将所有参数独立成行，保持4个空格缩进。

### 5. 条件语句
1. `if`和左圆括号间有一个空格；
2. 右圆括号和左大括号间有一个空格；
3. `else`与`if`的右大括号在同一行。

```cpp
if (condition) {
  ...
} else {
  ...
}
```

### 6. 循环和`switch`语句
1. 空循环应使用`{}`或`continue`，而不是简单的分号：
2. `switch`语句中的`case`块可以使用大括号；
3. `switch`语句总是要包含一个`default`。

```cpp
switch (var) {
  case 0: {
    ...
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
```

### 7. 指针和引用表达式
1. 句点`.`或箭头`->`前后不要有空格；
2. 指针/地址操作符（`*`、`&`）后不要有空格；
3. 声明指针或引用变量时，`*`和`&`与变量名紧挨。

```cpp
char *c;
const string &str;
```

### 8. 布尔表达式
一个布尔表达式超过80字符，断行时逻辑操作符位于行尾。

### 9. 函数返回值
函数返回时不要使用圆括号。

### 10. 预处理指令
预处理指令不要缩进，从行首开始。

### 11. 类格式
1. 基类名尽量与子类名放在同一行；
2. 关键字`public`、`protected`、`private`前缩进一个空格；
3. 除第一个关键字外，其他关键字前空一行；
4. 关键字后不要空行。

### 12. 初始化列表
构造函数初始化列表放在同一行或按四格缩进并排几行。

```cpp
Myclass::MyClass(int var)
    :some_var_(var),
     some_other_var_(var + 1) {
}
```

## 代码注释

### 1. 注释风格
使用`//`或`/* */`，统一就好。

### 2. 文件注释
通常`.h`文件要对所声明的类的功能和用法作简单说明，`.cc`文件的注释包含了更多的实现细节或算法讨论。

### 3. 类注释
每个类的定义要附着描述类的功能和用法的注释。

### 4. 函数注释
函数声明处注释描述函数功能及用法，注释使用描述式（“opens the file”）而非指令式（“Open the file”）。

函数声明处注释的内容：
1. 输入和输出；
2. 类成员函数：函数调用期间对象是否需要保持引用参数，是否会释放这些参数；
3. 如果函数分配了空间，需要由调用者释放；
4. 参数是否可以为`NULL`；
5. 是否存在函数使用的性能隐患；
6. 如果函数可重入，其同步前提是什么？

函数定义时要以注释说明函数功能和实现要点，如：实现的简要步骤、如此实现的理由等。

### 5. 变量注释
- 类数据成员：应注释说明用途，如果变量可以接受`NULL`或-1等警戒值，须说明之。
- 全局变量（常量）：和数据成员相似，也应注释说明含义及用途。

### 6. 实现注释
- 对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释；
- 行尾注释应在代码之后空两格；
- 前后相邻几行都有注释，调整对齐；
- 向函数传入`NULL`、布尔值或整数时，要注释说明含义；
- 永远不要用自然语言翻译代码作为注释。

## 头文件

### 1. `#define`保护
命名格式为：`<PROJECT>_<PATH>_<FILE>_H_`（待定）

### 2. 头文件依赖
使用前置声明尽量减少头文件中`#include`的数量。例如：头文件中用到类`FILE`，但不需要访问`FILE`的声明，则头文件中只需前置声明`class File`，无需include头文件。

以下情况可以做到使用类`Foo`而无需访问类的定义：
1. 将数据成员类型声明为`Foo *`或`Foo &`；
2. 参数、返回值类型为`Foo`的函数只是声明（但不定义实现）；
3. 静态数据成员的类型可以被声明为`Foo`，因为静态数据成员的定义在类定义之外。

注：不建议仅仅为了减少包含头文件就使用指针成员替代对象成员。

### 3. 函数参数顺序
定义函数时，参数顺序为：输入参数在前，输出参数在后。

### 4. 包含文件的名称及次序
项目内头文件应按照项目源代码目录树结构排列，相同目录下头文件按字母序排列。

例如：`src/foo/fooserver.cc`中包含头文件的次序如下：
```cpp
#include "foo/fooserver.h"  // 优先位置

#include <sys/types.h>  // C系统文件
#include <unistd.h>

#include <hash_map>  // 库头文件
#include <vector>

#include "base/basictypes.h"  // 本项目内头文件
#include "base/commandlineflags.h"
```

## 作用域

### 1. 命名空间
命名空间将除文件包含、全局标识的声明/定义以及类的前置声明外的整个源文件封装起来，以同其他命名空间相区分。
```cpp
namespace mynamespace {
// 所有声明都置于命名空间中，注意不要使用缩进
class MyClass {
};
}  // namespace mynamespace（结束时用注释标识）
```

在`.cc`文件、`.h`文件的函数或类中，可以使用`using`，其他地方禁止使用，防止污染命名空间。

相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用命名空间。

### 2. 局部变量
将函数变量尽可能置于最小作用域内（离第一次使用越近越好），在声明变量时将其初始化。

注：如果变量是一个对象，每次进入作用域都要调用构造函数，每次退出作用域都要调用析构函数。例如：
```cpp
// 低效的实现
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // 构造函数和析构函数分别调用1000000次
  f.DoSomething(i);
}

// 更好的实现
Foo f;
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

### 3. 全局变量
1. 禁止使用`class`类型的全局变量（包括`string`、`vector`等等），內建类型和由內建类型构成的没有构造函数的结构体可以使用。如果一定要使用`class`类型的全局变量，请使用单件模式（singleton pattern）；
2. 全局的字符串常量，使用C风格的字符串，不要使用STL的字符串；
    `const char str[] = "hello";`
3. 大多数全局变量应该考虑作为类的静态数据成员；
4. 只在`.cc`文件中使用的全局变量，应将其定义到不具名命名空间中，或使用`static`限制作用域；
5. 静态成员变量视作全局变量，不能是`class`类型。

## C++类

### 1. 构造函数的职责
构造函数只进行没有实际意义的（因为成员变量的“有意义”的值大多不在构造函数中确定）初始化，可能的话，使用`init()`方法集中初始化为有意义的数据，并（或）增加一个成员标记用于指示对象是否已经初始化成功。

### 2. 默认构造函数
如果类中定义了成员变量，没有提供其他的构造函数，你需要定义一个默认构造函数。如果你定义的类继承现有类，而又没有增加新的成员变量，则不需要为新类定义默认构造函数。

### 3. 显式构造函数
对单参数构造函数使用`explicit`关键字，防止隐式转换。拷贝构造函数可以不声明为`explicit`。

### 4. 拷贝构造函数
仅在代码中需要拷贝一个类的对象的时候使用拷贝构造函数。如果不需要拷贝，可以在类的`private`成员中添加空的拷贝构造函数和赋值操作。
```cpp
class Foo {
public:
  Foo(int f);
  ~Foo();

private:
  Foo(const Foo&);
  void operator=(const Foo&);
};
```

### 5. 继承
所有的继承必须是`public`的。

- 父类的纯虚函数：子类只继承接口，但必须实现其接口；
- 父类的虚函数：子类继承接口和实现，可以覆写（`override`），也可以使用默认版本。当覆写虚函数时，应在子类中明确声明其为`virtual`，提高可读性；
- 父类的非虚函数：子类继承接口和实现，不可以覆写。
- 如果类中有虚函数，其析构函数应该为虚函数。
- 限定仅在子类访问的成员函数为`protected`。

### 6. 存取控制
将数据成员私有化，并提供相关存取函数。如：定义变量`foo_`及取值函数`foo()`、赋值函数`set_foo()`。存取函数的定义一般内联在头文件中。

### 7. 声明次序
定义次序如下：`public`、`protected`、`private`，如果哪一块没有，直接忽略即可。

每一块中，声明次序一般如下：
1. `typedefs`和`enums`；
2. 常量；
3. 构造函数；
4. 析构函数；
5. 成员函数（含静态成员函数）；
6. 数据成员（含静态数据成员）。

`.cc`文件中函数的定义应尽可能和声明次序一致。

### 8. 编写短小函数
如果函数超过40行，可以考虑在不影响程序结构的情况下将其分割。

## 其他C++特性

### 1. 引用参数
所有按引用传递的参数必须加上`const`。输入参数为值或常引用，输出参数为指针。

### 2. 函数重载
仅在输入参数类型不同、功能相同时使用重载函数，不要使用函数重载模仿缺省函数参数。

```cpp
class MyClass {
public:
  void Analyze(const string &text);
  void Analyze(const char *text, size_t textlen);
};
```

与其重载一个函数，不如考虑让函数名包含参数信息，例如：`AppendString()`、`AppendInt()`。

### 3. 缺省参数
禁止使用缺省函数参数。避免使用可能不为程序员所知的缺省参数。

### 4. 变长数组和`alloca()`
禁止使用变长数组和`alloca()`。

### 5. 友元
允许合理使用友元类及友元函数。友元延伸了类的封装界线，当你希望只允许另一个类访问某个成员时，使用友元通常比将其声明为`public`要好得多。

### 6. 异常
不要使用C++异常。引入异常会牵连到所有依赖代码，会导致程序控制流通过查看代码无法确定。

### 7. 运行时类型识别RTTI
禁止使用RTTI。如果你需要在运行期间确定一个对象的类型，这通常说明你需要重新考虑你的类的设计。

### 8. 类型转换
使用C++风格而不要使用C风格类型转换。

1. `static_cast`：和C风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上转换；
2. `const_cast`：移除`const`属性；
3. `reinterpret_cast`：指针类型和整型或其他指针间不安全的相互转换（仅在你知道在做什么时使用）；
4. `dynamic_cast`：除测试外不要使用，参考RTTI。

### 9. 流
只在记录日志时使用流，其他使用`printf` + `read`/`write`。

### 10. 前置自增和自减
前置自增通常比后置自增效率更高，在不考虑表达式的值得情况下，使用前置自增和自减。

### 11. `const`的使用
尽可能地使用`const`。

1. 如果函数不会修改传入的引用或指针类型的参数，这样的参数应该为`const`；
2. 如果函数不会修改任何数据成员，也应该是`const`；
3. 不要返回对数据成员的非`const`指针或引用；
4. 如果数据成员在对象构造之后不再改变，可将其定义为`const`；
5. `const`的位置建议在前面。

### 12. 整型
- `<stdint.h>`定义了`int_16_t`、`int64_t`等整型，在需要确定大小的整型时可以使用它们代替`short`、`long long`等。
- 不要使用无符号整型，除非你是在表示一个位组（bit pattern）而不是一个数值。即使数值不会为负值也不要使用无符号类型，使用断言来保护数据。

### 13. 预处理宏
除了`#define`防止头文件重复包含外，不建议使用宏。

### 14. 0和`NULL`
- 整数：0
- 实数：0.0
- 指针：`NULL`
- 字符串：'\0'

### 15. `sizeof`
尽可能使用`sizeof(varname)`代替`sizeof(type)`。因为前者在变量类型改变时代码自动同步。
